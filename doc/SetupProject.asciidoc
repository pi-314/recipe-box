:highlightjsdir: highlight
:source-highlighter: highlight.js
:highlightjs-theme: atom-one-light

= Setup Angular18 - Jest - Tailwind - Spartan Project

_At the time of writing (Oct. 2024), there are numerous tutorials available for setting up an Angular project with Jest, Tailwind CSS, and Spartan/ui. However, many of these tutorials describe older versions of the frameworks and tools following partially deprecated conventions etc., which may be very confusing for developers who are not familiar with the latest versions of these tools._

The intention of this article is to provide a step-by-step guide on how to set up a project using the latest versions of these frameworks and tools, ensuring that you are following modern best practices and conventions.

*What we're going to do*:

Assuming we have already set up a Maven-based Java project, and want now to add an Angular frontend to it, following the https://en.wikipedia.org/wiki/Monorepo[monorepo] approach. This means that the Angular project will be placed in a separate folder at the top-level of your repository, while the Java project will remain in its original location, so our top-level directory structure looks like this:

[source, console]
----
<Java-project-root>
├── <AngularFrontend> <--- new top-level folder
├── src
├── README.md
└── pom.xml
----

== Prerequisites

For setting up an Angular project, you need to have *NodeJS* installed on your machine. Depending on your operating system, you can download the installer from the official NodeJS website: https://nodejs.org/en/download/[NodeJS Download] or use a package manager in your OS like `brew` on macOS, `choco` on Windows or `apt` on Linux as well as the tools like Node Version Manager (nvm) to manage multiple NodeJS versions on the same machine. For exact instructions, please refer to the official NodeJS documentation: https://nodejs.org/en/download/package-manager/[NodeJS Package Manager].

In following steps, we assume that NodeJS is already installed and available in the system path, so you can run the `node` and `npm` commands from the terminal like this:

[source, shell]
----
❯ node --version
v20.17.0
❯ npm --version
10.8.3
----

== Install Angular CLI

Angular CLI is a command-line interface for Angular applications. It provides a set of commands to create, build, test, and deploy Angular applications.

.Install Angular CLI (globally in this case) and check the version:
[source, shell]
----
❯ npm install -g @angular/cli \
  && ng version
----

.The output should look like this:
[source, console]
----
     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 18.2.6
Node: 20.17.0
Package Manager: npm 10.8.3
OS: darwin arm64

Angular: 18.2.6
... animations, cli, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1802.6
@angular-devkit/build-angular   18.2.6
@angular-devkit/core            18.2.6
@angular-devkit/schematics      18.2.6
@schematics/angular             18.2.6
rxjs                            7.8.1
typescript                      5.5.4
zone.js                         0.14.10
----

This will install the `ng` command, which we will use in most of the following setup steps.

NOTE: We installed Angular CLI globally in this case. Theoreticaly you can also install it locally in your project directory by omitting the `-g` flag. This may be useful if you for some reason want to have different versions of Angular CLI for different projects. However, it will create a `package.js` along with the `package-lock.js` file and the `node_modules` directory in your project folder, which may become quite tricky to manage correctly in the long run. Therefore, it is recommended to install Angular CLI globally and use the same version for all your projects.

== Create Angular Workspace

Since we are adding the frontend app on top of our Maven-based Java project, we will first create an empty Angular workspace in a separate top-level folder named `frontend`, which will also be the workspace's name.

IMPORTANT: Angular CLI expects, that the directory where you are going to create the Angular project is already under version control (Git). If it is not, you will be prompted to initialize a new Git repository in that directory, which might be not exactly what you want. Therefore, it is recommended to set up the Angular project in a directory that is already under version control.

.From the Java project root directory, create a new empty Angular workspace `frontend`:
[source, shell]
----
❯ ng new frontend --create-application false
----

.This will create a new top-level folder and populate it with the initial Angular configuration:
[source, console]
----
<Java-project-root>
├── frontend	      <—-- new Angular workspace
│   ├── .gitignore
│   ├── .editorconfig
│   ├── README.md
│   ├── angular.json
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── src
├── README.md
└── pom.xml
----

.Now we can cd into it:
[source, shell]
----
❯ cd frontend
----

IMPORTANT: All commands in the following steps should be executed from this directory, which is referred to as `_<NgWsRoot>_`.

== Create Angular app

.Generate our new app `recipe-box` (interactive):
[source, shell]
----
❯ ng generate application recipe-box
----

When prompted, choose:

 - CSS (since we are going to use the Tailwind CSS library) and 
 - no SSR

.The generator will show all changes made to the project:
[source, console]
----
? Which stylesheet format would you like to use? CSS [ https://developer.mozilla.org/docs/Web/CSS ]
? Do you want to enable Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering)? no
CREATE projects/recipe-box/src/app/app.component.css (0 bytes)
CREATE projects/recipe-box/src/app/app.component.html (19903 bytes)
CREATE projects/recipe-box/src/app/app.component.spec.ts (928 bytes)
CREATE projects/recipe-box/src/app/app.component.ts (306 bytes)
CREATE projects/recipe-box/src/main.ts (250 bytes)
CREATE projects/recipe-box/src/app/app.config.ts (310 bytes)
CREATE projects/recipe-box/src/app/app.routes.ts (77 bytes)
CREATE projects/recipe-box/tsconfig.app.json (432 bytes)
CREATE projects/recipe-box/tsconfig.spec.json (442 bytes)
CREATE projects/recipe-box/public/favicon.ico (15086 bytes)
CREATE projects/recipe-box/src/index.html (295 bytes)
CREATE projects/recipe-box/src/styles.css (80 bytes)
UPDATE angular.json (2805 bytes)
UPDATE package.json (1035 bytes)
✔ Packages installed successfully.
----

.Angular CLI generated a basic app structure and placed it inside the `projects` subdirectory:
[source, console]
----
<Java-project-root>
├── doc
├── frontend     <--- <NgWsRoot>
│   ├── projects        <----- new 'projects' subdirectory 
│   │   └── recipe-box  <----- new 'recipe-box' app
│   │       ├── public
│   │       │   └── favicon.ico
│   │       ├── src
│   │       │   ├── app
│   │       │   │   ├── app.component.css
│   │       │   │   ├── app.component.html
│   │       │   │   ├── app.component.spec.ts
│   │       │   │   ├── app.component.ts
│   │       │   │   ├── app.config.ts
│   │       │   │   └── app.routes.ts
│   │       │   ├── index.html
│   │       │   ├── main.ts
│   │       │   └── styles.css
│   │       ├── eslint.config.js
│   │       ├── tsconfig.app.json
│   │       └── tsconfig.spec.json
│   ├── .gitignore
│   ├── .editorconfig
│   ├── README.md
│   ├── angular.json
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── src
├── target
├── README.md
├── api-samples.http
├── compose.yml
└── pom.xml
----

== Setup ESLint

.Add ESLint (interactive, just follow the Angular CLI instructions then test):
[source, shell]
----
❯ ng lint
...
> frontend@0.0.0 lint
> ng lint

Linting "recipe-box"...

All files pass linting.
----

.Install ESLint JS Types (omited by default):
[source, shell]
----
❯ npm i --save-dev @types/eslint__js
----

IMPORTANT: ESLint 9.+ have introduced a new flat configuration format that is not yet fully supported by the Angular CLI `_angular-eslint_` plugin. Although ESLint can now accept `.js`, `.mjs`, `.cjs` files — and also `.ts`, `.mts`, and `.cts` (currently considered unstable, so available only with 'experimental' flag) — the Angular CLI is only compatible with a `.js` file extension, meaning that all generated configurations are still in the CommonJS format in `.js` files. Since the Angular app doesn't have a `"module":` declaration in its `tsconfig.json` file, that files should have actually the `.mjs` or `.cjs` extension, which is unfortunately not supported by the `angular-eslint` plugin at the moment. See https://github.com/angular-eslint/angular-eslint/issues/1859[angular-eslint#1859] for more details. +
 +
Therefore, we will continue using the `eslint.config.js` format with CJS syntax for now and transition to `.ts` files once the plugin supports all these formats. Until then, we should ignore the 'File is a CommonJS module; it may be converted to an ES module.ts(80001)' suggestion thrown by the TS compiler for these files.

=== VS Code extension for ESLint 

If your IDE is VS Code and you are using the https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint[ESLint extension], (which you are then strongly encouraged to do,) you may want to adjust the extension's settings, since it may not recognize by default your `eslint.config.js` file in the `frontend` subdirectory. To fix this, add the following to your `<ProjectRoot>/frontend/.vscode/settings.json` file:

[source, json]
----
{
  "eslint.workingDirectories": [
    "./frontend"
  ]
}
----

This will tell the ESLint extension to look for the ESLint configuration in the `frontend` subdirectory. Further more, you can also adjust a few other settings to make the extension work better with the Angular project:

[source, json]
----
{
  "js/ts.implicitProjectConfig.target": "ES2022",
  /*
    * If ESLint extension is installed, let it use correct 
    * (flat, eslint.config.js -format) settings for eslint v9.+
    */
  // Let ESLint use the same node version as the project (assumes 'node' is in the PATH)
  // Otherwise, it will use the version bundled with the extension
  "eslint.runtime": "node",
  // Use the flat config format (eslint.config.js) instead of the legacy .eslintrc
  "eslint.useFlatConfig": true,
  // Use the new ESLint class-based configuration
  "eslint.useESLintClass": true,
  // Format the code on save
  "editor.formatOnSave": true,
  // Use ESLint as the formatter
  "eslint.format.enable": true,
  // If multiple formatters are installed, ensure ESLint is the default one for JS
  "[javascript]": {
    "editor.defaultFormatter": "dbaeumer.vscode-eslint"
  },
  // Since we're using a monorepo directory layout, we need to tell eslint
  // where to start looking for the config(s):
  "eslint.workingDirectories": [
    {
      "directory": "./frontend",
    }
  ],
}
----

NOTE: We're putting these specific settings in the `.vscode/settings.json` file *in the `frontend` subdirectory*, so they will only apply to this Angular project, while the extension will continue using its 'usual' VS Code workspace settings for other projects.

Now you can enjoy the full power of the ESLint extension in your Angular project. It will show you the linting errors and warnings for all Angular specific artefacts (including HTML-Templates) directly in the editor, and you can fix them on the fly.

== Replace Karma with Jest

Replacing Karma with Jest in an Angular project can bring several benefits:

  - *Faster test execution*: Jest runs tests in parallel, making it much faster than Karma, which often uses slower browsers for testing.
  -	*Built-in features*: Jest comes with built-in functionalities like mocking, coverage reports, and snapshot testing, reducing the need for additional configurations and dependencies.
  -	*Simpler setup*: Jest is easier to set up and configure compared to Karma, which typically requires more dependencies (like a separate test runner and browser launcher).
  -	*Better developer experience*: Jest offers a more user-friendly interface with features like watch mode and clear test failure messages, improving the overall development and debugging process.

=== 1. Install Jest instead of Karma/Jasmine

First, we uninstall Karma, which is set up by default, and then install Jest along with a few other useful dependencies.

.Uninstall Karma:
[source, shell]
----
❯ npm uninstall \
    karma \
    karma-chrome-launcher \
    karma-coverage \
    karma-jasmine \
    karma-jasmine-html-reporter \
    jasmine-core \
    @types/jasmine
----

.Install Jest:
[source, bash]
----
❯ npm install --save-dev \
    jest \
    @types/jest \
    @jest/globals \
    jest-preset-angular \
    ts-node
----

IMPORTANT: `@jest/globals` allows you to use Jest's global functions like `describe`, `it`, `expect`, etc. in your test files without importing them explicitly. It mimics the behavior of Jasmine, which is the default testing framework for Angular projects. You may consider removing it if you prefer to import Jest functions explicitly. +
`ts-node` is required because we are going to use the `.ts` based configuration file syntax.

=== 2. Remove Karma test runner from `angular.json` file

.This fragment should be *REMOVED* from the `_<NgWsRoot>_/angular.json`:
[source,json]
----
...
        ,
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "projects/recipe-box/tsconfig.spec.json",
            "assets": [
              {
                "glob": "**/*",
                "input": "projects/recipe-box/public"
              }
            ],
            "styles": [
              "projects/recipe-box/src/styles.css"
            ],
            "scripts": []
          }
        }
...
----

NOTE: If migrating an existing project, you may also remove all orphaned Karma-related files at this step, i.e.:
`rm ./karma.conf.js ./src/test.ts`.

=== 3. Add a workspace-level `tsconfig.spec.json` file

.Add `_<NgWsRoot>_/tsconfig.spec.json`:
[source, json]
----
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
      "outDir": "./out-tsc/spec",
      "module": "CommonJs",
      "types": ["jest"]
    },
    "include": ["src/**/*.spec.ts", "src/**/*.d.ts"]
}
----

=== 4. Edit the app-level `tsconfig.spec.json` file
 - add "module"
 - in "types[]" change 'jasmine' -> 'jest' 

.Edit `_<NgWsRoot>_/projects/recipe-box/tsconfig.spec.json`:
[source,json]
----
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "../../out-tsc/spec",
    "module": "CommonJS",
    "types": [
      "jest"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}
----

=== 5. Add a workspace-level `setup-jest.ts` file

.Add `_<NgWsRoot>_/setup-jest.ts` with the following content:
[source, typescript]
----
import "jest-preset-angular/setup-jest";
----

=== 6. Add a workspace-level `jest.config.ts` file

.Add `_<NgWsRoot>_/jest.config.ts`:
[source,typescript]
----
import type { JestConfigWithTsJest } from 'ts-jest';

export default {

  preset: 'jest-preset-angular',
  setupFilesAfterEnv: ['<rootDir>/setup-jest.ts'],

} satisfies JestConfigWithTsJest;
----

=== 7. (Optional) Automatically migrate existing tests

.If migrating an existing project, you may consider also migrating your tests automatically:
[source,shell]
----
❯ npx jest-codemods
----

NOTE: The previously generated test `_<NgWsRoot>_/projects/recipe-box/src/app/app.component.spec.ts` in our new demo app does not need to be migrated.

=== 8. Modify and test scripts in `package.json`

.Edit `_<NgWsRoot>_/package.json`, adding or changing the following scripts:
[source,json]
----
  "test": "jest",
  "coverage": "jest --coverage"
----

.Test if everything is working correctly:
[source,shell]
----
❯ npm run coverage
----

.It should produce output like this:
[source, console]
----
> frontend@0.0.0 coverage
> jest --coverage

 PASS  projects/recipe-box/src/app/app.component.spec.ts
  AppComponent
    ✓ should create the app (58 ms)
    ✓ should have the 'recipe-box' title (7 ms)
    ✓ should render title (10 ms)

--------------------|---------|----------|---------|---------|-------------------
File                | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
--------------------|---------|----------|---------|---------|-------------------
All files           |     100 |      100 |     100 |     100 |                   
 app.component.html |     100 |      100 |     100 |     100 |                   
 app.component.ts   |     100 |      100 |     100 |     100 |                   
--------------------|---------|----------|---------|---------|-------------------
Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        0.983 s, estimated 58 s
Ran all test suites.
----

== Setup Tailwind CSS

https://tailwindcss.com/[Tailwind CSS] is a utility-first CSS framework that allows developers to build custom designs without writing custom CSS. It provides a set of utility classes that can be used to style elements directly in the HTML markup, making it easy to create responsive and visually appealing designs.

=== 1. Install and initialize Tailwind CSS:
[source, shell]
----
❯ npm install -D tailwindcss
❯ npx tailwindcss init
----

This will generate a new `_<NgWsRoot>_/tailwind.config.js` file.

=== 2. Configure paths

.Rename `_<NgWsRoot>_/tailwind.config.js` to `.ts` and edit its content as follows:
[source,typescript]
----
import type { Config } from 'tailwindcss'

export default {
  content: [
    './projects/**/*.{html,ts}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
} satisfies Config;
----

IMPORTANT: Contrary to what is stated in the official TailwindCSS documentation, the path here begins with './projects' to reflect our folder structure.

=== 3. Add `@tailwind` directives to our main CSS template

.Add to `_<NgWsRoot>_/projects/recipe-box/src/styles.css` the following content:
[source,css]
----
@tailwind base;
@tailwind components;
@tailwind utilities;
----

Now our project is ready to use the Tailwind CSS library.

== Setup Spartan NG UI Components

https://www.spartan.ng/documentation/installation[Spartan/ui] (currently in early alpha) is a https://ui.shadcn.com/[shadcn] -inspired set of UI primitives for Angular applications that are built on top of Angular CDK and Tailwind CSS and are fully customizable, allowing developers to create unique designs that fit their specific needs. The framework follows the same ideology as shadcn, meaning tha you do not install the component library, but rather copy the individual components into your project and customize them as needed.

=== 1. Install Spartan CLI, UI-Core and Angular CDK

.Install the Spartan CLI and the Spartan UI-Core library, as well as the Angular CDK:
[source, shell]
----
❯ npm i -D @spartan-ng/cli
❯ npm i @angular/cdk \
        @spartan-ng/ui-core
----

=== 2. Add Spartan-specific preset to the Tailwind CSS configuration

.Edit `_<NgWsRoot>_/tailwind.config.ts`:
[source,typescript]
----
import type { Config } from "tailwindcss";
import { hlmPreset } from "@spartan-ng/ui-core/hlm-tailwind-preset";

export default {
  presets: [hlmPreset],
  content: [
    './projects/**/*.{html,ts}',
    './libs/spartan/**/*.{html,ts}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
} satisfies Config;
----

=== 3. Setup the color theme

.Patch the app's main `styles.css` file with the definitions of the chosen color theme (interactive):
[source, shell]
----
❯ ng g @spartan-ng/cli:ui
----

When prompted, choose the desired theme. This will update the `_<NgWsRoot>_/projects/recipe-box/styles.css` file by adding the style definitions.

.Click to see the content of the updated `styles.css` file.
[%collapsible]
====
.`_<NgWsRoot>_/projects/recipe-box/src/styles.css`:
[source, css]
----
@import '@angular/cdk/overlay-prebuilt.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add global styles to this file, and also import other style files */
:root {
  --font-sans: ''
}

:root .theme-stone {
  --background: 0 0% 100%;
  --foreground: 20 14.3% 4.1%;
  --muted: 60 4.8% 95.9%;
  --muted-foreground: 25 5.3% 44.7%;
  --popover: 0 0% 100%;
  --popover-foreground: 20 14.3% 4.1%;
  --card: 0 0% 100%;
  --card-foreground: 20 14.3% 4.1%;
  --border: 20 5.9% 90%;
  --input: 20 5.9% 90%;
  --primary: 24 9.8% 10%;
  --primary-foreground: 60 9.1% 97.8%;
  --secondary: 60 4.8% 95.9%;
  --secondary-foreground: 24 9.8% 10%;
  --accent: 60 4.8% 95.9%;
  --accent-foreground: 24 9.8% 10%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 60 9.1% 97.8%;
  --ring: 20 14.3% 4.1%;
  --radius: 0.5rem;
  color-scheme: light;
}

.dark .theme-stone {
  --background: 20 14.3% 4.1%;
  --foreground: 60 9.1% 97.8%;
  --muted: 12 6.5% 15.1%;
  --muted-foreground: 24 5.4% 63.9%;
  --popover: 20 14.3% 4.1%;
  --popover-foreground: 60 9.1% 97.8%;
  --card: 20 14.3% 4.1%;
  --card-foreground: 60 9.1% 97.8%;
  --border: 12 6.5% 15.1%;
  --input: 12 6.5% 15.1%;
  --primary: 60 9.1% 97.8%;
  --primary-foreground: 24 9.8% 10%;
  --secondary: 12 6.5% 15.1%;
  --secondary-foreground: 60 9.1% 97.8%;
  --accent: 12 6.5% 15.1%;
  --accent-foreground: 60 9.1% 97.8%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 60 9.1% 97.8%;
  --ring: 24 5.7% 82.9%;
  color-scheme: dark;
}
----
====


=== 4. Add required primitives (UI Components) to the project (interactive)

[source, shell]
----
❯ ng g @spartan-ng/cli:ui
----

When prompted, use `libs/spartan` as the directory where the libraries should be placed. This will organize the components as follows:

[source, console]
----
<NgWsRoot>
├── libs
│   └── spartan
│       ├── ui-alert-helm
│       ├── ui-badge-helm
│       ├── ui-button-helm
│       ├── ui-command-helm
│       ├── ui-formfield-helm
│       ├── ui-icon-helm
│       ├── ui-input-helm
│       ├── ui-label-helm
│       ├── ui-pagination-helm
│       ├── ui-popover-helm
│       ├── ui-scrollarea-helm
│       ├── ui-sonner-helm
│       └── ui-tooltip-helm
├── projects
├── README.md
├── angular.json
├── eslint.config.js
├── jest.config.ts
├── package-lock.json
├── package.json
├── setup-jest.ts
├── tailwind.config.ts
├── tsconfig.json
└── tsconfig.spec.json
----

=== 5. Fix Spartan/ui tests

Since the Spartan/ui components are part of the project's sources, it is always a good practice to include their tests in the project's usual QA/CI cycle, to ensures that any changes to the source code of these components (which you are absolutely free to make!) do not cause unexpected bugs or side effects.

==== 5.1. Install missing dependency

Unfortunately, the official installation instructions omit at the moment an important dependency required for the Spartan/ui tests to compile. This can be easily fixed by manually installing `@testing-library/angular`:

.Install the missing dependency:
[source, shell]
----
❯ ng add @testing-library/angular
----

IMPORTANT: When prompted, choose to install both the `jest-dom` and the `user-event`.

==== 5.2. Make `compilerOptions.paths` mapping available for Jest

During the installation of the individual components, the Spartan CLI adds the mapping between the source code of the installed components and the corresponding package names to the `_<NgWsRoot>_/tsconfig.json` file, making it available to the TypeScript compiler. Since this is a compile-time dependency, Jest is still unaware of this mapping, so we need to make it available for Jest as well.

For more details s. https://kulshekhar.github.io/ts-jest/docs/getting-started/paths-mapping/ 

.Edit the `_<NgWsRoot>_/jest.config.ts` file like this:
[source, typescript]
----
import { compilerOptions } from './tsconfig.json' // <--- add this
import { pathsToModuleNameMapper } from 'ts-jest' // <--- add this
import type { JestConfigWithTsJest } from 'ts-jest'

export default {
    preset: 'jest-preset-angular',
    setupFilesAfterEnv: ['<rootDir>/setup-jest.ts'],

    moduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths , { prefix: '<rootDir>/' }), // <--- add this

} satisfies JestConfigWithTsJest;
----

Now, when you run your project tests as usual, you will notice that the tests for the Spartan/ui components are included as well:

[source,console]
----
❯ npm run coverage

> frontend@0.0.0 coverage
> jest --coverage

 PASS  projects/recipe-box/src/app/app.component.spec.ts
 PASS  libs/spartan/ui-formfield-helm/src/lib/form-field.spec.ts     <--- notice this test
 PASS  libs/spartan/ui-icon-helm/src/lib/hlm-icon.component.spec.ts  <--- and this one
----------------------------------------|---------|----------|---------|---------|-------------------
File                                    | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------------------------------------|---------|----------|---------|---------|-------------------
All files                               |   94.66 |    84.21 |   82.14 |   94.57 |                   
 libs/spartan/ui-button-helm/src        |     100 |      100 |     100 |     100 |                   
  index.ts                              |     100 |      100 |     100 |     100 |                   
 libs/spartan/ui-button-helm/src/lib    |      80 |      100 |      25 |   78.57 |                   
  hlm-button.directive.ts               |      80 |      100 |      25 |   78.57 | 49,55,61          
 libs/spartan/ui-formfield-helm/src/lib |      95 |    83.33 |     100 |   93.33 |                   
  hlm-error.directive.ts                |     100 |      100 |     100 |     100 |                   
  hlm-form-field.component.ts           |   91.66 |    83.33 |     100 |    90.9 | 37                
  hlm-hint.directive.ts                 |     100 |      100 |     100 |     100 |                   
 libs/spartan/ui-icon-helm/src          |     100 |      100 |     100 |     100 |                   
  index.ts                              |     100 |      100 |     100 |     100 |                   
 libs/spartan/ui-icon-helm/src/lib      |     100 |    83.33 |     100 |     100 |                   
  hlm-icon.component.ts                 |     100 |    83.33 |     100 |     100 | 88,97             
 libs/spartan/ui-input-helm/src         |     100 |      100 |     100 |     100 |                   
  index.ts                              |     100 |      100 |     100 |     100 |                   
 libs/spartan/ui-input-helm/src/lib     |   89.18 |      100 |      75 |    90.9 |                   
  hlm-input-error.directive.ts          |   66.66 |      100 |       0 |   71.42 | 20-21             
  hlm-input.directive.ts                |   96.42 |      100 |   85.71 |   96.15 | 49                
 projects/recipe-box/src/app            |     100 |      100 |     100 |     100 |                   
  app.component.html                    |     100 |      100 |     100 |     100 |                   
  app.component.ts                      |     100 |      100 |     100 |     100 |                   
----------------------------------------|---------|----------|---------|---------|-------------------

Test Suites: 3 passed, 3 total
Tests:       13 passed, 13 total
Snapshots:   0 total
Time:        1.364 s
Ran all test suites.
----

==== 5.3. Ignoring Spartan/ui tests

If you don't want the Spartan/ui tests to be executed each time (e.g., if you are not intended to make any changes to those components and want to reduce resource consumption on your CI server), you can instruct Jest to ignore them.

.Edit `_<NgWsRoot>_/jest.config.ts`, adding the `testPathIgnorePatterns` option: 
[source,typescript]
----
import { compilerOptions } from './tsconfig.json'
import { pathsToModuleNameMapper } from 'ts-jest'
import type { JestConfigWithTsJest } from 'ts-jest'

export default {
    preset: 'jest-preset-angular',
    setupFilesAfterEnv: ['<rootDir>/setup-jest.ts'],

    moduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths , { prefix: '<rootDir>/' }),

    testPathIgnorePatterns: [       // <--- add this
       '<rootDir>/libs/spartan/',
    ],

} satisfies JestConfigWithTsJest;
----

Now only the tests from the app are included into the test run:
[source, console]
----
❯ npm run coverage

> frontend@0.0.0 coverage
> jest --coverage

 PASS  projects/recipe-box/src/app/app.component.spec.ts
  AppComponent
    ✓ should create the app (60 ms)
    ✓ should have the 'recipe-box' title (7 ms)
    ✓ should render title (23 ms)

-------------------------------------|---------|----------|---------|---------|-------------------
File                                 | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------------------------------|---------|----------|---------|---------|-------------------
All files                            |   92.94 |    58.33 |    64.7 |      92 |                   
 libs/spartan/ui-button-helm/src     |     100 |      100 |     100 |     100 |                   
  index.ts                           |     100 |      100 |     100 |     100 |                   
 libs/spartan/ui-button-helm/src/lib |      80 |      100 |      25 |   78.57 |                   
  hlm-button.directive.ts            |      80 |      100 |      25 |   78.57 | 49,55,61          
 libs/spartan/ui-icon-helm/src       |     100 |      100 |     100 |     100 |                   
  index.ts                           |     100 |      100 |     100 |     100 |                   
 libs/spartan/ui-icon-helm/src/lib   |   93.33 |    58.33 |   76.92 |   92.85 |                   
  hlm-icon.component.ts              |   93.33 |    58.33 |   76.92 |   92.85 | 123-133           
 projects/recipe-box/src/app         |     100 |      100 |     100 |     100 |                   
  app.component.html                 |     100 |      100 |     100 |     100 |                   
  app.component.ts                   |     100 |      100 |     100 |     100 |                   
-------------------------------------|---------|----------|---------|---------|-------------------
Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        0.78 s, estimated 1 s
Ran all test suites.
----

IMPORTANT: Comparing these results to those of the previous test run, you should notice that the code coverage achieved this time has decreased *significantly*. It's up to you to decide whether the Spartan UI component tests should be run each time or excluded from regular test runs, as this highly depends on your intended development and CI scenario.


== Setup End-to-End Testing with Playwright

https://playwright.dev/[Playwright] is an open-source, cross-browser test framework. It enables developers to write end-to-end tests for web applications, supporting multiple browsers such as Chromium, Firefox, and WebKit. Playwright provides a unified API for automating browser interactions, making it easier to test web applications across different environments and ensuring consistent behavior. It is known for its reliability, speed, and ability to handle modern web features like single-page applications and mobile web.

=== 1. Install Playwright
[source, shell]
----
❯ npm init playwright@latest
----

When prompted, choose:

  - `e2e` as the directory for end-to-end tests
  - `true` to add a GitHub Actions workflow, if you are using GitHub CI
  - `true` to install Playwright browsers

.Click to see more details and *how to fix a vulnerability warnings*.
[%collapsible]
====

.Installation output:
[source, console]
----
❯ npm init playwright@latest

Need to install the following packages:
create-playwright@1.17.134
Ok to proceed? (y) 

> frontend@0.0.0 npx
> create-playwright

Getting started with writing end-to-end tests with Playwright:
Initializing project in '.'
✔ Where to put your end-to-end tests? · e2e
✔ Add a GitHub Actions workflow? (y/N) · true
✔ Install Playwright browsers (can be done manually via 'npx playwright install')? (Y/n) · true
Installing Playwright Test (npm install --save-dev @playwright/test)…

added 3 packages, and audited 1837 packages in 6s

219 packages are looking for funding
  run `npm fund` for details

10 low severity vulnerabilities      * - s. Note below

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
Installing Types (npm install --save-dev @types/node)…

added 1 package, and audited 1838 packages in 1s

219 packages are looking for funding
  run `npm fund` for details


10 low severity vulnerabilities

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.

Writing playwright.config.ts.
Writing .github/workflows/playwright.yml.
Writing e2e/example.spec.ts.
Writing tests-examples/demo-todo-app.spec.ts.
Writing package.json.
Downloading browsers (npx playwright install)…
✔ Success! Created a Playwright Test project at /Users/paul/PROG/recipe-box/frontend

Inside that directory, you can run several commands:

  npx playwright test
    Runs the end-to-end tests.

  npx playwright test --ui
    Starts the interactive UI mode.

  npx playwright test --project=chromium
    Runs the tests only on Desktop Chrome.

  npx playwright test example
    Runs the tests in a specific file.

  npx playwright test --debug
    Runs the tests in debug mode.

  npx playwright codegen
    Auto generate tests with Codegen.

We suggest that you begin by typing:

    npx playwright test

And check out the following files:
  - ./e2e/example.spec.ts - Example end-to-end test
  - ./tests-examples/demo-todo-app.spec.ts - Demo Todo App end-to-end tests
  - ./playwright.config.ts - Playwright Test configuration

Visit https://playwright.dev/docs/intro for more information. ✨

Happy hacking! 🎭
----

NOTE: At the time of writing, one of the transitive dependencies of the Playwright package has a known minor vulnerability https://github.com/jshttp/cookie/security/advisories/GHSA-pxg6-pf52-xh8x[CVE-2024-47764], so `npm` warns you about it. +
*Don't try to fix it with `npm audit fix --force` as it will bring no effect!*

You should address this correctly by specifying the exact desired version of the affected package in your `package.json` file.

.Fixing the vulnerability:
[source, json]
----
"overrides": {
  "cookie": "0.7.1"
},
----

.Then run `npm install` to apply the changes:
[source, shell]
----
❯ npm install
----

After this `npm` should show `0 vulnerabilities` in the output of the `npm audit` command.


====

=== 2. Adjust the `e2e` directory structure
 
During the installation, Playwright created an `e2e` directory in the `_<NgWsRoot>_` directory for end-to-end tests. It also generated a sample test file `example.spec.ts` and a more advanced example test file `demo-todo-app.spec.ts` in the `tests-examples` directory. We will organize these files by moving `example.spec.ts` into a new `src` subdirectory within `e2e`, and relocating both the `tests-examples` directory and the `playwright.config.ts` file into the `e2e` directory as follows:

[source, shell]
----
❯ mkdir e2e/src
❯ mv e2e/example.spec.ts e2e/src
❯ mv tests-examples e2e
❯ mv playwright.config.ts e2e
----

.The directory structure should finally look like this:
[source, console]
----
<NgWsRoot>
├── ...
├── e2e
│   ├── src
│   │   └── example.spec.ts
│   ├── tests-examples
│   │   └── demo-todo-app.spec.ts
│   └─ playwright.config.ts
└── ...
----

=== 3. Move the `.github/workflows` directory to the root of the repository

Playwright also created a `.github/workflows` directory with a preconfigured GitHub Actions workflow file `playwright.yml`.

NOTE: If you are not intended to host your project on GitHub or use GitHub CI, you can skip this step, removing that `.github` directory entirely or just answer with `false` to the corresponding question during the Playwright installation process. For other CI systems, you will need to create your own configuration accordingly.

.Move the `.github` directory to the root of the project:
[source, shell]
----
❯ mv .github ..
----

.and adjust the path in the `playwright.yml` file accordingly:
[source, yaml]
----
name: Frontend Playwright Tests
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
jobs:
  test:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    # .......... add this section .........
    defaults:
      run:
        working-directory: './frontend'
    # .....................................
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: lts/*
    - name: Install dependencies
      run: npm ci
    - name: Install Playwright Browsers
      run: npx playwright install --with-deps
    - name: Run Playwright tests
      run: npx playwright test
    - uses: actions/upload-artifact@v4
      if: ${{ !cancelled() }}
      with:
        # ....... also adjust this ........
        name: ./frontend/playwright-report
        path: playwright-report/
        retention-days: 30
----

If set up correctly, the GitHub Actions workflow will run the Playwright tests on each push to the `main` or `master` branch and on each pull request.

.Playwright workflow in GitHub Actions
image::resources/playwright-workflow-execution.png[PlaywrightWorkflow, width=80%]

=== 4. Install the Playwright ESLint plugin

.Install the `eslint-plugin-playwright` package:
[source, shell]
----
❯ npm install --save-dev eslint-plugin-playwright
----

.Then, add the plugin to the ESLint configuration file `_<NgWsRoot>_/e2e/eslint.config.js`:
[source, js]
----
const baseConfig = require("../eslint.config.js");
const playwright = require('eslint-plugin-playwright'); // <-- add this

module.exports = [
  ...baseConfig,
  {
    ...playwright.configs['flat/recommended'],  // <-- add this
    files: ['src/**'],
  },
  {
    files: ['src/**'],
    rules: {
      // Overwrite or add Playwright rules here
      // ...
    },
  },
];
----

.Now you can run your end-to-end tests with Playwright:
[source, shell]
----
❯ npx playwright test e2e

Running 3 tests using 3 workers
  3 passed (8.9s)

To open last HTML report run:

  npx playwright show-report
----

.and see the test results:
[source, console]
----
❯ npx playwright show-report
----

It will open a browser window with the test results, where you can navigate through all details of each test:

.Playwright Test Report
image::resources/playwright-test-report.png[PlaywrightTestReport, width=80%]

